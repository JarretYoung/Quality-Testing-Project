+=============================================+
|                                             |
|            FIT2107 Assignment 2             |
|      Test Strategies and Justification      |
|                                             |
+=============================================+=========+
|Students:                                              |
| - Garret Yong Shern Min (31862616)                    |
| - Yip Kin Keat (30722063)                             |
| - Choo Bi Shan (33053758)                             |
+=======================================================+

(]==============================================================[)
Student Name :          Garret Yong Shern Min
Student ID :            31862616
Sections Worked on :    Events & Navigation
Branches Created :      application_navigation_feature
                        deleting_events_tester
                        creating_events_tester
 
          ==============================================
For the creation of the test cases, several testing strategies were put into play to ensure the feasibility and robustness of the application.
 
The inspiration for the test cases for the creation/ starting of events would be the MC/DC testing method. This is due to the nature of the validation check that had to be conducted by the check_event_input() method which takes in 5 arguments. If I were to test every possible combination, there would be 32 test cases alone for the validation check. Hence MC/DC testing was used to only target important combinations with the widest coverage. Eventually, the number of test cases was reduced to 14. In addition, branch coverage testing strategy was kept in mind when designing all my test cases. Especially for creation of events where there are many decision statements which should be tested for feasibility and robustness.
 
There were several black box testing strategy rules that were included to increase the coverage of the test cases. For instance, when testing date entry, Equivalence Partitioning’s must rule dictated that there had to be one test case for invalid date and one for valid. However, since the invalid test cases for yyyy-mm-dd format and dd-MON-yy format were the same, they could be merged; however, to ensure branch coverage(because of the use of try, except statements to check the date formats) the two were kept separate. Another example of the must rule would be that all inputs must not be None or an empty string. So by combining MC/DC testing with this Equivalence Partitioning(EP) rule, we are able to easily cover the assertion of no missing input by having at least one valid input while one invalid input for each missing input. Besides that, validation done for the locations involved checking the state codes and postcodes. State codes are usually 2-3 characters long while postcodes are usually 4-5 digits long, since the valid test case was created (as mentioned earlier using MC/DC testing) we follow the EP rule of ranges. Hence two invalid cases were created each where one was testing below minimum and the other testing above maximum. 
 
The next development was the delete and cancel functions for the application. Due to the nature of the application, delete and cancel functions have drastically similar functionalities whereby the event is deleted from the API (cancel just stores the deleted event in the application’s archive list). Based on the specification, only past events are allowed to be deleted and/or cancelled which means that this falls under the Equivalence Partitioning’s range rule but since there is no minimum for the range, only one valid and one invalid test cases needed to be developed. However, due to the programming of the application which tries to prevent errors (keeps asking for input until valid) testing invalid input would be impossible using the UI. So, first the valid test cases were developed for both delete and cancel functions by simulating user inputs and validating (checking) the output to ensure that the values match up with expectations. On the other hand, to ensure an invalid case would be present, invalid inputs are inserted into the delete_existing_event() method in MyEventManager.py; this is done as the method will raise an error if the event’s date is during the future. In addition, since deleting and cancelling events can use the same invalid test case, only one test case is developed for both functionalities. 
 
The next development was the restore function, despite not being mentioned in the specifications explicitly, the notation was indicative that this function needed to be developed. Due to the application’s nature to prevent user error, and since there are no constraints to which events can or cannot be restored, there is only one test case present to prove that the function works. In a sense, the testing strategy used was intuition testing. 
 
The final development from my part would be the query function which allows users to search for specific events based on certain keywords/ queries. For this function, there are multiple categories which mainly include query by name and query by date time. This specification has no constraints that are explicitly mentioned so some assumptions were made. When querying the name of the event, the name cannot be None nor an empty string; when querying the start and end date, the input must follow the yyyy-mm-dd format. So, when developing the test cases for this section similar test strategies to the create events are used to ensure maximum coverage. When querying the names of the events via full name and keyword, one invalid test case with input as empty string and another valid test case with a non-empty string input and double-checking the queried events (Equivalence Partitioning: Must rule). Then, for querying start and end dates each, one input of incorrect/ invalid date format input and another of valid date format input (Equivalence Partitioning: Must rule). 

(]==============================================================[)

(]==============================================================[)
Student Name :          Yip Kin Keat
Student ID :            30722063
Sections Worked on :    Attendees & Import/Export
Branches Created :      attendees
                        import-export
          ==============================================

A total of four test suites were created for my part. 

Firstly, the AddAttendeeTest. The addAttendee() function in MyEventManager.py, which allows event organisers to add a specific attendee, will be tested in this test suite. The addAttendee() function requires a Google Calendar API object, the email address of the new attendee, and the eventId of the updated event. According to the Google Calendar API reference document, using the input eventId would enable us to immediately access and add the participant to that event. To ensure that each branch is tested, Branch Coverage was used. Because each decision node has only one condition in our case, Condition Coverage would also apply because each condition in those decision nodes would be true or false at least once. Our branches included determining whether the input attendee email is in a valid format, determining whether the number of attendees in the event has already reached our maximum capacity (20 attendees), whether the event is set after 2050, and determining whether the number of attendees changed after adding the attendee from that event. When testing the maximum capacity of attendees at an event, boundary value analysis was also used. Mocking is also used to mock the API object, where the mocked API object is used to add the attendee of the event. Following the addition of an attendee, we would check to see if the total number of attendees increased by one. If the attendee could not be added successfully, any errors or Exceptions would be caught, causing the addAttendee() function to return False. Our test cases would simply determine whether the add attendee process was successful and whether the number of attendees changed. Fo certain cases where number of attendee does not change after addition, it wouldsimply mean that the given email user is already an existing attendee.

Next, the RemoveAttendeeTest. The removeAttendee() function in MyEventManager.py, which enables event organisers to remove a specific attendee, will be tested in this test suite. The removeAttendee() function requires a Google Calendar API object, the email address of the attendee who is to be deleted, and the eventId of the changed event. In accordance with the guidelines in the Google Calendar API reference paper, the input eventId would enable us to immediately access and remove the attendee in that event. Working very similarly to "AddAttendeeTest", Branch Coverage and Condition Coverage was also used here. Our branches included determining whether the input attendee email is of a valid format, and determining whether the number of attendees changed after the attendee was removed from the event. Mocking is also used to mock the API object. Following the removal of an attendee, we would check to see if the total number of attendees decreased by one. Any problems or Exceptions would also be caught if the attendee removal attempt failed, making the removeAttendee() function return False. Our test cases would merely determine whether the process to delete an attendee was successful and whether the total number of attendees changed. The removeAttendee() function would also return False in situations when the number of attendees did not change after removal, indicating that the given email user is not an attendee in the event.

Moving on to ImportEventTest, in this test suite the importEventFromJSON() function in MyEventManager.py is tested. This fucntion allows user to import events from a file. The importEventFromJSON() function accepts two arguments: a Google calendar API object and the path to the JSON syntax file containing the event information. Furthermore, the fact that the file's contents must be in JSON syntax enables the event to be imported regardless of the file format (Python or JSON file). To ensure that each condition and branch are tested, condition and branch coverage was used. In our example, the branches are exception catchers such as FileNotFoundError (when user provides wrong file paths) and JSONDecodeError (when user specifies a file that does not follow standard json syntax). We guarantee that each of the catches mentioned above will be executed at least once by using condition and branch coverage, and when none of them are executed, the event is successfully imported. In order to construct the event using the contents of the file, the API object is also mocked using this technique. Our test cases would simply determine whether the event import procedure worked well, and if it did, the event link would likewise be generated. 

Lastly, the ExportEventTest. The exportEventToJson() function in MyEventManager.py, which enables users to export an event from Google Calendar to a JSON file, will be tested as part of this test suite. This function is similar to the import function where it takes in the Google Calendar API object, eventId and of course the destination path where the event specified by the eventId is exported to. Similarly, Branch coverage was used to guarantee that each branch has been tested. Since each decision node in our example only has one condition, condition coverage would also be applicable because every condition would either be true or false at least once. In this instance, the branches serve as the exception handler for FileNotFoundError (which occurs when a user enters a file path that is incorrect) and also check to see if the user has entered a file path or not; if not, the event is exported to the current directory. Mocking is also used to mock the API object, where the mocked object uses the given eventId to get the event.

(]==============================================================[)
